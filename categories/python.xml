<?xml version="1.0" encoding="utf-8"?>
<?xml-stylesheet type="text/xsl" href="../assets/xml/rss.xsl" media="all"?><rss version="2.0" xmlns:dc="http://purl.org/dc/elements/1.1/" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>绿萝间 (Python)</title><link>https://muxuezi.github.io/</link><description></description><atom:link type="application/rss+xml" href="https://muxuezi.github.io/categories/python.xml" rel="self"></atom:link><language>en</language><lastBuildDate>Sun, 21 Feb 2016 05:44:04 GMT</lastBuildDate><generator>https://getnikola.com/</generator><docs>http://blogs.law.harvard.edu/tech/rss</docs><item><title>Zen of Python</title><link>https://muxuezi.github.io/posts/zen-of-python.html</link><dc:creator>Tao Junjie</dc:creator><description>&lt;div&gt;&lt;h2&gt;Python已经25岁&lt;/h2&gt;
&lt;p&gt;&lt;strong&gt;祝Python生日快乐！&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;img alt="happy25" src="https://muxuezi.github.io/posts/happy25.jpg"&gt;&lt;/p&gt;
&lt;p&gt;1991年2月20日，荷兰人（Dutch）Guido van Rossum发布了Python的0.9.0版，至今25年。Python简洁优雅高效，应用极其广泛，在科学计算、机器学习、系统管理、网络开发等众多领域愈加光彩夺目。译Python设计哲学分享给大家：&lt;/p&gt;
&lt;pre class="code literal-block"&gt;&lt;span&gt;&lt;/span&gt;Python设计哲学，作者Tim Peters（The Zen of Python, by Tim Peters）

美观优于丑陋（Beautiful is better than ugly.）
显明胜过隐晦（Explicit is better than implicit.）
复杂优于混乱（Complex is better than complicated.）
扁平胜过嵌套（Flat is better than nested.）
广泛优于深邃（Sparse is better than dense.）
可读性不可或缺（Readability counts.）
特例不能破坏规则（Special cases aren't special enough to break the rules.）
即使复杂现实会打破纯粹规则（Although practicality beats purity.）
异常不能不辞而别（Errors should never pass silently.）
除非需要它悄然无声（Unless explicitly silenced.）
模棱两可时，不要胡思乱想（In the face of ambiguity, refuse the temptation to guess.）
应该有且仅有一种明确的方式解决问题（There should be one-- and preferably only one-- obvious way to do it.）
虽然那种方式起初并非显而易见，除非你是Guido（Although that way may not be obvious at first unless you're Dutch.）
现在做比不做好（Now is better than never.）
虽然不做比急于求成好（Although never is often better than *right* now.）
如果结果很难解释，一定不靠谱（If the implementation is hard to explain, it's a bad idea.）
如果容易解释，也许行得通（If the implementation is easy to explain, it may be a good idea.）.
命名空间是个非常好的理念——让我们继续努力吧！（Namespaces are one honking great idea -- let's do more of those!）
&lt;/pre&gt;


&lt;blockquote&gt;
&lt;p&gt;原文在(Pytyon官方网站）[https://www.python.org/]打开shell（黄色按钮），命令行里输入import this即可看到。&lt;/p&gt;
&lt;p&gt;Guido大叔今年60岁（1956年1月31日），依然在为Python社区贡献力量，写代码，做演讲，宣传Python新特性，乐此不疲。人生苦短，Python当歌！&lt;/p&gt;
&lt;/blockquote&gt;&lt;/div&gt;</description><category>Python</category><guid>https://muxuezi.github.io/posts/zen-of-python.html</guid><pubDate>Sun, 21 Feb 2016 05:20:52 GMT</pubDate></item><item><title>6.Utilizing Parallel Python</title><link>https://muxuezi.github.io/posts/6utilizing-parallel-python.html</link><dc:creator>Tao Junjie</dc:creator><description>&lt;div tabindex="-1" id="notebook" class="border-box-sizing"&gt;
    &lt;div class="container" id="notebook-container"&gt;

&lt;div class="cell border-box-sizing text_cell rendered"&gt;
&lt;div class="prompt input_prompt"&gt;
&lt;/div&gt;
&lt;div class="inner_cell"&gt;
&lt;div class="text_cell_render border-box-sizing rendered_html"&gt;
&lt;h2 id="用Parallel-Python模块"&gt;用Parallel Python模块&lt;a class="anchor-link" href="https://muxuezi.github.io/posts/6utilizing-parallel-python.html#%E7%94%A8Parallel-Python%E6%A8%A1%E5%9D%97"&gt;¶&lt;/a&gt;&lt;/h2&gt;&lt;p&gt;上一章我们用&lt;code&gt;multiprocessing&lt;/code&gt;和&lt;code&gt;ProcessPoolExecutor&lt;/code&gt;模块演示了两个例子。这一章我们将介绍命名队列（named pipe）的用法，以及如何用&lt;strong&gt; Parallel Python (PP)&lt;/strong&gt;模块的进程解决问题。&lt;/p&gt;
&lt;p&gt;本章内容包括以下主题：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;理解进程间通信概念&lt;/li&gt;
&lt;li&gt;介绍PP模块&lt;/li&gt;
&lt;li&gt;用PP在SMP架上计算Fibonacci数列&lt;/li&gt;
&lt;li&gt;用PP实现并行网络爬虫&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;a href="https://muxuezi.github.io/posts/6utilizing-parallel-python.html"&gt;Read more…&lt;/a&gt; (3 min remaining to read)&lt;/p&gt;&lt;/div&gt;&lt;/div&gt;&lt;/div&gt;&lt;/div&gt;&lt;/div&gt;</description><category>Parallel Programming with Python</category><category>Python</category><guid>https://muxuezi.github.io/posts/6utilizing-parallel-python.html</guid><pubDate>Sat, 03 Oct 2015 04:44:35 GMT</pubDate></item><item><title>5.Using Multiprocessing and ProcessPoolExecutor</title><link>https://muxuezi.github.io/posts/5using-multiprocessing-and-processpoolexecutor.html</link><dc:creator>Tao Junjie</dc:creator><description>&lt;div tabindex="-1" id="notebook" class="border-box-sizing"&gt;
    &lt;div class="container" id="notebook-container"&gt;

&lt;div class="cell border-box-sizing text_cell rendered"&gt;
&lt;div class="prompt input_prompt"&gt;
&lt;/div&gt;
&lt;div class="inner_cell"&gt;
&lt;div class="text_cell_render border-box-sizing rendered_html"&gt;
&lt;h2 id="用multiprocessing和ProcessPoolExecutor模块"&gt;用&lt;code&gt;multiprocessing&lt;/code&gt;和&lt;code&gt;ProcessPoolExecutor&lt;/code&gt;模块&lt;a class="anchor-link" href="https://muxuezi.github.io/posts/5using-multiprocessing-and-processpoolexecutor.html#%E7%94%A8multiprocessing%E5%92%8CProcessPoolExecutor%E6%A8%A1%E5%9D%97"&gt;¶&lt;/a&gt;&lt;/h2&gt;&lt;p&gt;上一章我们用&lt;code&gt;threading&lt;/code&gt;模块演示了两个例子。这一章我们将介绍&lt;code&gt;multiprocessing&lt;/code&gt;的用法，实现与&lt;code&gt;threading&lt;/code&gt;类似的接口。但是，我们将用进程范式。&lt;/p&gt;
&lt;p&gt;本章内容包括以下主题：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;理解进程的概念&lt;/li&gt;
&lt;li&gt;理解多进程通信&lt;/li&gt;
&lt;li&gt;用&lt;code&gt;multiprocessing&lt;/code&gt;实现多请求的Fibonacci数列&lt;/li&gt;
&lt;li&gt;用&lt;code&gt;ProcessPoolExecutor&lt;/code&gt;实现并行网络爬虫&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;a href="https://muxuezi.github.io/posts/5using-multiprocessing-and-processpoolexecutor.html"&gt;Read more…&lt;/a&gt; (2 min remaining to read)&lt;/p&gt;&lt;/div&gt;&lt;/div&gt;&lt;/div&gt;&lt;/div&gt;&lt;/div&gt;</description><category>Parallel Programming with Python</category><category>Python</category><guid>https://muxuezi.github.io/posts/5using-multiprocessing-and-processpoolexecutor.html</guid><pubDate>Tue, 29 Sep 2015 12:53:28 GMT</pubDate></item><item><title>4.Using the threading and concurrent.futures Modules</title><link>https://muxuezi.github.io/posts/4using-the-threading-and-concurrentfutures-modules.html</link><dc:creator>Tao Junjie</dc:creator><description>&lt;div tabindex="-1" id="notebook" class="border-box-sizing"&gt;
    &lt;div class="container" id="notebook-container"&gt;

&lt;div class="cell border-box-sizing text_cell rendered"&gt;
&lt;div class="prompt input_prompt"&gt;
&lt;/div&gt;
&lt;div class="inner_cell"&gt;
&lt;div class="text_cell_render border-box-sizing rendered_html"&gt;
&lt;h2 id="4.用threading和concurrent.futures模块"&gt;4.用&lt;code&gt;threading&lt;/code&gt;和&lt;code&gt;concurrent.futures&lt;/code&gt;模块&lt;a class="anchor-link" href="https://muxuezi.github.io/posts/4using-the-threading-and-concurrentfutures-modules.html#4.%E7%94%A8threading%E5%92%8Cconcurrent.futures%E6%A8%A1%E5%9D%97"&gt;¶&lt;/a&gt;&lt;/h2&gt;&lt;p&gt;在上一章，我们总结了并行思想可以解决的一些问题。这一章，我们将用Python的&lt;code&gt;threading&lt;/code&gt;模块实现每个问题的解决方案。&lt;/p&gt;
&lt;p&gt;本章内容包括以下主题：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;线程的定义&lt;/li&gt;
&lt;li&gt;&lt;code&gt;threading&lt;/code&gt;和&lt;code&gt;_thread&lt;/code&gt;的选择&lt;/li&gt;
&lt;li&gt;用&lt;code&gt;threading&lt;/code&gt;实现多请求的Fibonacci数列&lt;/li&gt;
&lt;li&gt;用&lt;code&gt;concurrent.futures&lt;/code&gt;模块实现网络爬虫&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;a href="https://muxuezi.github.io/posts/4using-the-threading-and-concurrentfutures-modules.html"&gt;Read more…&lt;/a&gt; (2 min remaining to read)&lt;/p&gt;&lt;/div&gt;&lt;/div&gt;&lt;/div&gt;&lt;/div&gt;&lt;/div&gt;</description><category>Parallel Programming with Python</category><category>Python</category><guid>https://muxuezi.github.io/posts/4using-the-threading-and-concurrentfutures-modules.html</guid><pubDate>Mon, 28 Sep 2015 12:42:03 GMT</pubDate></item><item><title>2-working-with-linear-models</title><link>https://muxuezi.github.io/posts/2-working-with-linear-models.html</link><dc:creator>Tao Junjie</dc:creator><description>&lt;div tabindex="-1" id="notebook" class="border-box-sizing"&gt;
    &lt;div class="container" id="notebook-container"&gt;

&lt;div class="cell border-box-sizing text_cell rendered"&gt;
&lt;div class="prompt input_prompt"&gt;
&lt;/div&gt;
&lt;div class="inner_cell"&gt;
&lt;div class="text_cell_render border-box-sizing rendered_html"&gt;
&lt;h2 id="处理线性模型"&gt;处理线性模型&lt;a class="anchor-link" href="https://muxuezi.github.io/posts/2-working-with-linear-models.html#%E5%A4%84%E7%90%86%E7%BA%BF%E6%80%A7%E6%A8%A1%E5%9E%8B"&gt;¶&lt;/a&gt;&lt;/h2&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div class="cell border-box-sizing text_cell rendered"&gt;
&lt;div class="prompt input_prompt"&gt;
&lt;/div&gt;
&lt;div class="inner_cell"&gt;
&lt;div class="text_cell_render border-box-sizing rendered_html"&gt;
&lt;p&gt;本章包括以下主题：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;&lt;a href="https://muxuezi.github.io/posts/fitting-a-line-through-data.html"&gt;线性回归模型&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="https://muxuezi.github.io/posts/evaluating-the-linear-regression-model.html"&gt;评估线性回归模型&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="https://muxuezi.github.io/posts/using-ridge-regression-to-overcome-linear-regression-shortfalls.html"&gt;用岭回归弥补线性回归的不足&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="https://muxuezi.github.io/posts/optimizing-the-ridge-regression-parameter.html"&gt;优化岭回归参数&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="https://muxuezi.github.io/posts/using-sparsity-to-regularize-models.html"&gt;LASSO正则化&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="https://muxuezi.github.io/posts/taking-a-more-fundamental-approach-to-regularization-with-lars.html"&gt;LARS正则化&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="https://muxuezi.github.io/posts/using-linear-methods-for-classification-logistic-regression.html"&gt;用线性方法处理分类问题——逻辑回归&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="https://muxuezi.github.io/posts/directly-applying-bayesian-ridge-regression.html"&gt;贝叶斯岭回归&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="https://muxuezi.github.io/posts/using-boosting-to-learn-from-errors.html"&gt;用梯度提升回归从误差中学习&lt;/a&gt;&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;&lt;a href="https://muxuezi.github.io/posts/2-working-with-linear-models.html"&gt;Read more…&lt;/a&gt; (1 min remaining to read)&lt;/p&gt;&lt;/div&gt;&lt;/div&gt;&lt;/div&gt;&lt;/div&gt;&lt;/div&gt;</description><category>CHS</category><category>ipython</category><category>Machine Learning</category><category>Python</category><category>scikit-learn cookbook</category><guid>https://muxuezi.github.io/posts/2-working-with-linear-models.html</guid><pubDate>Tue, 18 Aug 2015 05:07:14 GMT</pubDate></item><item><title>directly-applying-bayesian-ridge-regression</title><link>https://muxuezi.github.io/posts/directly-applying-bayesian-ridge-regression.html</link><dc:creator>Tao Junjie</dc:creator><description>&lt;div tabindex="-1" id="notebook" class="border-box-sizing"&gt;
    &lt;div class="container" id="notebook-container"&gt;

&lt;div class="cell border-box-sizing text_cell rendered"&gt;
&lt;div class="prompt input_prompt"&gt;
&lt;/div&gt;
&lt;div class="inner_cell"&gt;
&lt;div class="text_cell_render border-box-sizing rendered_html"&gt;
&lt;h2 id="贝叶斯岭回归"&gt;贝叶斯岭回归&lt;a class="anchor-link" href="https://muxuezi.github.io/posts/directly-applying-bayesian-ridge-regression.html#%E8%B4%9D%E5%8F%B6%E6%96%AF%E5%B2%AD%E5%9B%9E%E5%BD%92"&gt;¶&lt;/a&gt;&lt;/h2&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div class="cell border-box-sizing text_cell rendered"&gt;
&lt;div class="prompt input_prompt"&gt;
&lt;/div&gt;
&lt;div class="inner_cell"&gt;
&lt;div class="text_cell_render border-box-sizing rendered_html"&gt;
&lt;p&gt;在&lt;em&gt;用岭回归弥补线性回归的不足&lt;/em&gt;主题中，我们介绍了岭回归优化的限制条件。我们还介绍了相关系数的先验概率分布的贝叶斯解释，将很大程度地影响着先验概率分布，先验概率分布通常均值是0。&lt;/p&gt;
&lt;p&gt;因此，现在我们就来演示如何scikit-learn来应用这种解释。&lt;/p&gt;
&lt;p&gt;&lt;a href="https://muxuezi.github.io/posts/directly-applying-bayesian-ridge-regression.html"&gt;Read more…&lt;/a&gt; (1 min remaining to read)&lt;/p&gt;&lt;/div&gt;&lt;/div&gt;&lt;/div&gt;&lt;/div&gt;&lt;/div&gt;</description><category>CHS</category><category>ipython</category><category>Machine Learning</category><category>Python</category><category>scikit-learn cookbook</category><guid>https://muxuezi.github.io/posts/directly-applying-bayesian-ridge-regression.html</guid><pubDate>Tue, 18 Aug 2015 04:57:47 GMT</pubDate></item><item><title>evaluating-the-linear-regression-model</title><link>https://muxuezi.github.io/posts/evaluating-the-linear-regression-model.html</link><dc:creator>Tao Junjie</dc:creator><description>&lt;div tabindex="-1" id="notebook" class="border-box-sizing"&gt;
    &lt;div class="container" id="notebook-container"&gt;

&lt;div class="cell border-box-sizing text_cell rendered"&gt;
&lt;div class="prompt input_prompt"&gt;
&lt;/div&gt;
&lt;div class="inner_cell"&gt;
&lt;div class="text_cell_render border-box-sizing rendered_html"&gt;
&lt;h2 id="评估线性回归模型"&gt;评估线性回归模型&lt;a class="anchor-link" href="https://muxuezi.github.io/posts/evaluating-the-linear-regression-model.html#%E8%AF%84%E4%BC%B0%E7%BA%BF%E6%80%A7%E5%9B%9E%E5%BD%92%E6%A8%A1%E5%9E%8B"&gt;¶&lt;/a&gt;&lt;/h2&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div class="cell border-box-sizing text_cell rendered"&gt;
&lt;div class="prompt input_prompt"&gt;
&lt;/div&gt;
&lt;div class="inner_cell"&gt;
&lt;div class="text_cell_render border-box-sizing rendered_html"&gt;
&lt;p&gt;在这个主题中，我们将介绍回归模型拟合数据的效果。上一个主题我们拟合了数据，但是并没太关注拟合的效果。每当拟合工作做完之后，我们应该问的第一个问题就是“拟合的效果如何？”本主题将回答这个问题。&lt;/p&gt;
&lt;p&gt;&lt;a href="https://muxuezi.github.io/posts/evaluating-the-linear-regression-model.html"&gt;Read more…&lt;/a&gt; (2 min remaining to read)&lt;/p&gt;&lt;/div&gt;&lt;/div&gt;&lt;/div&gt;&lt;/div&gt;&lt;/div&gt;</description><category>CHS</category><category>ipython</category><category>Machine Learning</category><category>Python</category><category>scikit-learn cookbook</category><guid>https://muxuezi.github.io/posts/evaluating-the-linear-regression-model.html</guid><pubDate>Tue, 18 Aug 2015 04:57:47 GMT</pubDate></item><item><title>using-ridge-regression-to-overcome-linear-regression-shortfalls</title><link>https://muxuezi.github.io/posts/using-ridge-regression-to-overcome-linear-regression-shortfalls.html</link><dc:creator>Tao Junjie</dc:creator><description>&lt;div tabindex="-1" id="notebook" class="border-box-sizing"&gt;
    &lt;div class="container" id="notebook-container"&gt;

&lt;div class="cell border-box-sizing text_cell rendered"&gt;
&lt;div class="prompt input_prompt"&gt;
&lt;/div&gt;
&lt;div class="inner_cell"&gt;
&lt;div class="text_cell_render border-box-sizing rendered_html"&gt;
&lt;h2 id="用岭回归弥补线性回归的不足"&gt;用岭回归弥补线性回归的不足&lt;a class="anchor-link" href="https://muxuezi.github.io/posts/using-ridge-regression-to-overcome-linear-regression-shortfalls.html#%E7%94%A8%E5%B2%AD%E5%9B%9E%E5%BD%92%E5%BC%A5%E8%A1%A5%E7%BA%BF%E6%80%A7%E5%9B%9E%E5%BD%92%E7%9A%84%E4%B8%8D%E8%B6%B3"&gt;¶&lt;/a&gt;&lt;/h2&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div class="cell border-box-sizing text_cell rendered"&gt;
&lt;div class="prompt input_prompt"&gt;
&lt;/div&gt;
&lt;div class="inner_cell"&gt;
&lt;div class="text_cell_render border-box-sizing rendered_html"&gt;
&lt;p&gt;本主题将介绍岭回归。和线性回归不同，它引入了正则化参数来“缩减”相关系数。当数据集中存在共线因素时，岭回归会很有用。&lt;/p&gt;
&lt;p&gt;&lt;a href="https://muxuezi.github.io/posts/using-ridge-regression-to-overcome-linear-regression-shortfalls.html"&gt;Read more…&lt;/a&gt; (1 min remaining to read)&lt;/p&gt;&lt;/div&gt;&lt;/div&gt;&lt;/div&gt;&lt;/div&gt;&lt;/div&gt;</description><category>CHS</category><category>ipython</category><category>Machine Learning</category><category>Python</category><category>scikit-learn cookbook</category><guid>https://muxuezi.github.io/posts/using-ridge-regression-to-overcome-linear-regression-shortfalls.html</guid><pubDate>Tue, 18 Aug 2015 04:57:47 GMT</pubDate></item><item><title>using-linear-methods-for-classification-logistic-regression</title><link>https://muxuezi.github.io/posts/using-linear-methods-for-classification-logistic-regression.html</link><dc:creator>Tao Junjie</dc:creator><description>&lt;div tabindex="-1" id="notebook" class="border-box-sizing"&gt;
    &lt;div class="container" id="notebook-container"&gt;

&lt;div class="cell border-box-sizing text_cell rendered"&gt;
&lt;div class="prompt input_prompt"&gt;
&lt;/div&gt;
&lt;div class="inner_cell"&gt;
&lt;div class="text_cell_render border-box-sizing rendered_html"&gt;
&lt;h2 id="用线性方法处理分类问题——逻辑回归"&gt;用线性方法处理分类问题——逻辑回归&lt;a class="anchor-link" href="https://muxuezi.github.io/posts/using-linear-methods-for-classification-logistic-regression.html#%E7%94%A8%E7%BA%BF%E6%80%A7%E6%96%B9%E6%B3%95%E5%A4%84%E7%90%86%E5%88%86%E7%B1%BB%E9%97%AE%E9%A2%98%E2%80%94%E2%80%94%E9%80%BB%E8%BE%91%E5%9B%9E%E5%BD%92"&gt;¶&lt;/a&gt;&lt;/h2&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div class="cell border-box-sizing text_cell rendered"&gt;
&lt;div class="prompt input_prompt"&gt;
&lt;/div&gt;
&lt;div class="inner_cell"&gt;
&lt;div class="text_cell_render border-box-sizing rendered_html"&gt;
&lt;p&gt;实际上线性模型也可以用于分类任务。方法是把一个线性模型拟合成某个类型的概率分布，然后用一个函数建立阈值来确定结果属于哪一类。&lt;/p&gt;
&lt;p&gt;&lt;a href="https://muxuezi.github.io/posts/using-linear-methods-for-classification-logistic-regression.html"&gt;Read more…&lt;/a&gt; (1 min remaining to read)&lt;/p&gt;&lt;/div&gt;&lt;/div&gt;&lt;/div&gt;&lt;/div&gt;&lt;/div&gt;</description><category>CHS</category><category>ipython</category><category>Machine Learning</category><category>Python</category><category>scikit-learn cookbook</category><guid>https://muxuezi.github.io/posts/using-linear-methods-for-classification-logistic-regression.html</guid><pubDate>Tue, 18 Aug 2015 04:57:47 GMT</pubDate></item><item><title>optimizing-the-ridge-regression-parameter</title><link>https://muxuezi.github.io/posts/optimizing-the-ridge-regression-parameter.html</link><dc:creator>Tao Junjie</dc:creator><description>&lt;div tabindex="-1" id="notebook" class="border-box-sizing"&gt;
    &lt;div class="container" id="notebook-container"&gt;

&lt;div class="cell border-box-sizing text_cell rendered"&gt;
&lt;div class="prompt input_prompt"&gt;
&lt;/div&gt;
&lt;div class="inner_cell"&gt;
&lt;div class="text_cell_render border-box-sizing rendered_html"&gt;
&lt;h2 id="优化岭回归参数"&gt;优化岭回归参数&lt;a class="anchor-link" href="https://muxuezi.github.io/posts/optimizing-the-ridge-regression-parameter.html#%E4%BC%98%E5%8C%96%E5%B2%AD%E5%9B%9E%E5%BD%92%E5%8F%82%E6%95%B0"&gt;¶&lt;/a&gt;&lt;/h2&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div class="cell border-box-sizing text_cell rendered"&gt;
&lt;div class="prompt input_prompt"&gt;
&lt;/div&gt;
&lt;div class="inner_cell"&gt;
&lt;div class="text_cell_render border-box-sizing rendered_html"&gt;
&lt;p&gt;当你使用岭回归模型进行建模时，需要考虑&lt;code&gt;Ridge&lt;/code&gt;的&lt;code&gt;alpha&lt;/code&gt;参数。&lt;/p&gt;
&lt;p&gt;例如，用OLS（普通最小二乘法）做回归也许可以显示两个变量之间的某些关系；但是，当&lt;code&gt;alpha&lt;/code&gt;参数正则化之后，那些关系就会消失。做决策时，这些关系是否需要考虑就显得很重要了。&lt;/p&gt;
&lt;p&gt;&lt;a href="https://muxuezi.github.io/posts/optimizing-the-ridge-regression-parameter.html"&gt;Read more…&lt;/a&gt; (1 min remaining to read)&lt;/p&gt;&lt;/div&gt;&lt;/div&gt;&lt;/div&gt;&lt;/div&gt;&lt;/div&gt;</description><category>CHS</category><category>ipython</category><category>Machine Learning</category><category>Python</category><category>scikit-learn cookbook</category><guid>https://muxuezi.github.io/posts/optimizing-the-ridge-regression-parameter.html</guid><pubDate>Tue, 18 Aug 2015 04:57:47 GMT</pubDate></item></channel></rss>