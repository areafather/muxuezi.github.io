<?xml version="1.0" encoding="utf-8"?>
<?xml-stylesheet type="text/xsl" href="../assets/xml/rss.xsl" media="all"?><rss xmlns:atom="http://www.w3.org/2005/Atom" xmlns:dc="http://purl.org/dc/elements/1.1/" version="2.0"><channel><title>绿萝间 (Posts about Python)</title><link>https://muxuezi.github.io/</link><description></description><atom:link href="https://muxuezi.github.io/categories/python.xml" type="application/rss+xml" rel="self"></atom:link><language>en</language><lastBuildDate>Mon, 13 Feb 2017 01:02:49 GMT</lastBuildDate><generator>Nikola (getnikola.com)</generator><docs>http://blogs.law.harvard.edu/tech/rss</docs><item><title>Python solo 6 years</title><link>https://muxuezi.github.io/posts/python-solo-6-years.html</link><dc:creator>Tao Junjie</dc:creator><description>&lt;div&gt;&lt;h2&gt;Python solo 六年记&lt;/h2&gt;
&lt;p&gt;人生几何？Python 当歌！&lt;/p&gt;
&lt;p&gt;我的博客“绿萝间”里记载了近六年的学习历程，大都是围绕 Python 而做。没有仔细梳理，信号嘈杂，噪音扰民。看我博客的人不多（ Google analysis 分析数据），估计大都是彩民（彩票数据用 Python 分析的）。记得李敖曾经说，看他早期著作的读者，都是在地下色情书刊买错了书的色情狂，想象那些平日里满眼格子的X，见到李敖的嘻笑怒骂，顿然醍醐灌顶，拍案叫绝。还有法国大革命前，巴黎市民读到的哲学，大多混杂于书商斗篷内的诽谤小说，对集权体制的批判与质疑从此开始。学贯中西的公知已经很多，我的博客没那么高大上，都是烂笔头里磨出的一些杂碎。&lt;/p&gt;
&lt;p&gt;一切皆是历史，学习就是读史。罗马政治家西塞罗有句名言：一个不知道自己出生前发生了什么事情的人，等于没有长大。而立之年，不能不学历史。学历史方法很多，读书是系统学习的方法之一，也适合我的个性。梁文道说，读书不是为了让你很安静地逃离这个世界，而是为了让你回到这个世界，换一种方式来认知这个世界，接触这个世界。总之，文以载道，不能不读书。知与行，学与思，皆非一日之功，需小锅慢炖，厚积薄发。在工作和生活中，我一直用 Python，简洁、高效、开源，自带电池，开箱即用，快乐多多。沉舟侧畔，几经风霜，颠覆妄想症的时期已经过去。积跬步，做小事，乐生活。＂成功未必在我，功成其中有我＂，足矣。&lt;/p&gt;
&lt;p&gt;一切交流，无论表现形式，皆有翻译（信息编码与解码）。翻译是知识传播的重要途径，形式多样。目前，人肉翻译是中国 ICT 领域的主流娱乐形式之一，机器翻译仍然在“信达雅”的入门阶段，值得期待。如果你大学时学过谭浩强书记的《 C 语言程序设计》，很可能被推荐阅读北大教授翻译的经典，如《计算机程序的构造和解释》、《 C++ 程序设计语言》（比 C 还高级），大多数人在阅读过程中会怀疑自己看不懂中文，在自习室看两页正好睡觉。这样的译本，只能加深对编程的恐惧，在图书馆看作者原著之后，发现原文根本没那么拗口，大师写的基础教程，读者众多，一定是大众读物，通俗易懂的；翻译不当，只会误人子弟，不过教授现在也开始写《数据结构与算法：Python 语言描述》了。偶遇图灵社区网站，才知道原来有这么多道友，可谓热闹非凡。翻译书这事儿，合我胃口。一个人静静的做一件复杂的事情，不用开会，没有需求变更，没有线上线下，和我修电脑，修手机，修自行车，是一个套路。以前，很闲很有时间；现在，班车路上时间很长（平均1小时），有时间将看的书整理成文字。我不是科班出身，语言功底薄弱，因此只能简单译。我认为翻译是一种个性化解释器，掺杂了译者习惯，难免信息损失，如果有时间，可以看原文，更接近作者，但中国人终究还是要用中文解释的，好译本是掌握知识的捷径，而且非常便宜。技术翻译应该简洁、直接、骨感，越精确越复杂越容易陷入小我偏离主题。快刀斩乱麻，直截了当，大家都痛快（作者，译者，读者）。具体手法：文章由句子构成，句子=单词+（上下文）+结构。 map 解决单词意思、 filter 解决上下文关联、 reduce 解决句子结构，遇到坑，直接联系作者解决。&lt;/p&gt;
&lt;p&gt;六年工作和学习内容最终总结为五本译作。有幸认识图灵社区的老师们，她们专业、高效、开放的做事风格，令人倾佩。三本书已经由图灵社区出版，其中《 Python 网络数据采集》总结如何获取网络数据，存储数据，十分有趣；《 Python 性能分析与优化》重点介绍代码优化方法，提高 Python 程序性能；《 Python 科学计算基础教程》介绍 Python 的科学计算的生态环境，有一章专门介绍 Python 在科学与工程领域的应用案例，让人大开眼界。这三本书构成了 Python 数据分析的基础环境：基于数据库，获取数据，优化性能，科学分析。还缺一环，做成产品，也是我未来继续努力的方向。在学习 Python 的过程中遇到的坑不少，不过前人都已踩过，这些书给了我很多帮助。有段时间，我陷入了性能优化的泥潭，总怀疑性能不佳要优化。我家莉姐一语点破，其实能解决问题就好，优化也要花时间。我家莉姐总能一语中的，吾之大幸。 Python 其实并不慢，Guido 老爹说过。&lt;/p&gt;
&lt;p&gt;另外两本书在博客中，纯属自娱自乐。在数据分析方面，尤其感兴趣机器学习，译有《精通 Scikit-learn 机器学习》，介绍了经典的回归，聚类，分类，降维学习方法，用里面的方法协助一位朋友完成了论文，很有成就感。未完成的《 Scikit-learn Machine Learning Cookbook 》，对 scikit-learn 和 theano 的总结，同样很有趣（一本更赞的机器学习书正在翻译中）。在 app 开发方面，翻译有《 Kivy 指南》，Kivy是一款多平台 app 开发框架，在国内没什么声音，可能是 JavasScript 太火，也可能是网络不太方便。 Kivy 跨平台能力强，支持 Windows， Mac OS X， Linux， Android， iOS， WP 系统应用开发，可以借助Python丰富的模块扩展应用功能。另外还有 Kivy Launcher，支持即时代码运行，把代码复制到手机的 kivy 目录下即可在手机上运行 app 。另外，统计学方面翻译有 Jake VanderPlas 的博文《频率主义与贝叶斯主义》四篇，用 Python 对比统计方法，适合教学。在 Python 自动化方面，翻译了 PyAutoGUI 程序包的中文文档，可以控制鼠标、键盘事件。 PyAutoGUI 接口简洁，绝对有潜力成为 GUI（ Autocad， PS ）自动化神器。另外， Selenium 也支持的网页交互功能，在《 Python 网络数据采集》中有介绍。&lt;/p&gt;
&lt;p&gt;用 Python 做数据分析的初衷是分析彩票（双色球与大乐透），也是我博客的主要内容，以前用 matlab，装一次费老大劲，速度也比较慢，在手机上没法儿运行，2010年整理维基百科的数据时，遇到了 Numpy， matlab 基本可以无缝过渡到 Python 。复兴数十步，豁然开朗。 Python 的世界更精彩，围绕数据库，前面有高效灵活的数据采集工具（ requests， lxml， aiohttp ），中间有交互式的数据分析与可视化工具（ pandas， scikit-learn， theano， matplotlib， bokeh， seaborn ），后面有简便快捷 webapp 开发框架（ flask， django ）， awesome Python 。博客原来是 WordPress，现在用 Python 的 Nikola 静态页面生成框架，放在 github 上。彩票分析方法在网上都是描述性统计，我用 pandas+scikit-learn，红球样本数据量不大（C 33，6即1107568），神经网络方法简单、随机。如果有100万用户，一人一注，肯定有人中大奖。如果你真中了，记得给我捐点首付哈。如有雷同，纯属巧合。彩票不是随机事件，如果是真随机，停售后立即开奖好了，为什么在20点停售后，到21:15才开奖？因为这段时间里，计算机要枚举所有中奖可能（红球110758，蓝球16，即17721088）与当期销售的上亿订单中奖情况，大矩阵做 MapReduce，计算奖金总数，给用出奖最小的6+1组合，然后让机器把球转出来，最后由冷静的主持人和公证人员秀一下，公正公平公开，您中奖了吗？买彩票也是一种修行，参悟乌合之众的共性，找到与众不同的那注球。未来不可预测，信号与噪声难以识别，《信号与噪声》这本书中文版翻译得挺好，推荐。&lt;/p&gt;
&lt;p&gt;有时间读书，是一件幸福的事。几年在国企，确实有时间，可以把以前的基础课程重学一遍，再读经典，开卷有益。以前在学校图书馆看书，常常整天整天的呆着图书馆，后来莉姐也到图书馆工作了，读书方便。引以为傲的，是自己还是读书人，修炼的终极目标依然是扫地僧，有一门手艺，博览群书。重看了 C， C++， java，数据结构与算法，SQL，操作系统和编译原理，还挑战过七周七语言。参与过 swift 中文文档的翻译，梁杰在 github 组织众包翻译，让人印象深刻，是中国程序员团结协作，面向新知识，面向世界，面向开源的典范。看的最多的还是 Python，简洁、优雅、高效，丰富的程序库，非常适合开发网络应用，做数据采集与分析，也适合编程教学。现在国外许多大学已经将 Python 作为编程第一课了，相信未来国内也会如此。文科生不需要指针，也可以快乐的编程。更加重要的是培养小朋友们编程解决问题的能力。如果在工作学习中，需要大量的重复，甚至在100个网页中 Ctrl+C 和 Ctrl+V 任务，那绝对是教育的缺失。既然智能硬件已如此便宜，人人都可以用上智能手机，那么完全可以改变教学方法，网络教学在线互动，让小朋友在游戏互动中学习公式，定理，观察物理化学现象，会大大激发学习热情。兴趣永远是最好的老师。&lt;/p&gt;
&lt;p&gt;用编程解决问题是提高工作效率的有效手段。编程这种思维方式，可以快速解决重复问题。人生就是一个循环选择（ for...if...else... ）的过程，而计算机的本质功能就是通过程序让重复变得简单，可靠，持续。科学，工程与商业领域都在不断努力让计算机替代人类做重复的事情，数据的采集与计算成本越来越低，各行各业的数据科学都在快速发展，问题的数据边界渐渐清晰。我非计算机科班出身，专业是物流与工业工程，物流是工业工程的分支，属于科学管理范畴，涉及面广，是一门杂学。科学管理的根源，在于社会分工体系成熟之后，重复劳动现象凸显，一个人的操作时间节省1%，企业都会节省巨大的成本。物流、工业工程与计算机科学以及其他科学的基本任务一致，即努力解决时空稀缺性问题。其流程复杂，节点众多，对数据有迫切需求。随着自动化技术的进步，业务量的集中，大型物流园区兴起，倒逼整个行业从劳动密集型转向技术密集型转变。目前的物流系统仅仅处于聚合数据阶段，标记流程节点，关于作业效率优化，如库存控制，拣选路径，排程系统，配送路由问题，都需要面对具体业务，做深入挖掘，寻找优化方案，这是现代物流应该做的事情。&lt;/p&gt;
&lt;p&gt;不管怎么耍一天只有24小时。除非超越光速，否则干什么都不会改变一天的长度，时间一天天的过去，我还是在数据的海洋里寻觅。 Python 就是一支长篙，让我可以向青草更深处漫溯，希望有一天我也可以满载星辉，在星辉斑斓里放歌，希望眼前的苟且与诗和远方能够合理并发（ Concurrency ）。&lt;/p&gt;&lt;/div&gt;</description><category>Python</category><guid>https://muxuezi.github.io/posts/python-solo-6-years.html</guid><pubDate>Sun, 25 Sep 2016 04:11:03 GMT</pubDate></item><item><title>Python网络数据采集</title><link>https://muxuezi.github.io/posts/chs-web-scarping-with-python.html</link><dc:creator>Tao Junjie</dc:creator><description>&lt;div&gt;&lt;p&gt;网络爬虫是采集数据的主要手段之一，是大众喜闻乐见的计算机技术。工作和学习中经常通过Python写爬虫采集数据，偶然看到O'Reilly这本&lt;a href="http://item.m.jd.com/product/11896401.html"&gt;《Python网络数据采集》(Web Scarping with Python)&lt;/a&gt;，作者经验丰富，给了我们很多帮助，感谢图灵社区给我们机会。Python写爬虫是很有趣的事情，电脑上装上&lt;a href="https://www.continuum.io/downloads"&gt;Anaconda&lt;/a&gt;，就可以开始啦。写网络爬虫是一件很有成就感的事情，简单易用，老少皆宜，是学习编程计算的好起点。不过，数据量非常大或者考虑长期商用时，还是与对方建立合作关系更加合适。本书算是第一份工作的总结，那段时间有空，挺好！&lt;/p&gt;
&lt;p&gt;下面分享我们的译者序，感谢小宝在我们翻译时安静的陪伴。&lt;/p&gt;
&lt;h2&gt;《Python网络数据采集》译者序&lt;/h2&gt;
&lt;p&gt;每时每刻，搜索引擎和网站都在采集大量信息，非原创即采集。采集信息用的程序一般被称为网络爬虫（Web crawler）、网络铲（Web scraper，可类比考古用的洛阳铲）、网络蜘蛛（Web spider），其行为一般是先“爬”到对应的网页上，再把需要的信息“铲”下来。O'Reilly这本书的封面图案是一只穿山甲，图灵公司把这本书的中文版定名为“Python网络数据采集”。当我们看完这本书的时候，觉得网络数据采集程序也像是一只辛勤采蜜的小蜜蜂，它飞到花（目标网页）上，采集花粉（需要的信息），经过处理（数据清洗、存储）变成蜂蜜（可用的数据）。网络数据采集可以为生活加点儿蜜，亦如本书作者所说，“网络数据采集是为普通大众所喜闻乐见的计算机巫术”。&lt;/p&gt;
&lt;p&gt;网络数据采集大有所为。在大数据深入人心的时代，网络数据采集作为网络、数据库与机器学习等领域的交汇点，已经成为满足个性化网络数据需求的最佳实践。搜索引擎可以满足人们对数据的共性需求，即“我来了，我看见”，而网络数据采集技术可以进一步精炼数据，把网络中杂乱无章的数据聚合成合理规范的形式，方便分析与挖掘，真正实现“我征服”。工作中，你可能经常为找数据而烦恼，或者眼睁睁看着眼前的几百页数据却只能长恨咫尺天涯，又或者数据杂乱无章的网站中满是带有陷阱的表单和坑爹的验证码，甚至需要的数据都在网页版的PDF和网络图片中。而作为一名网站管理员，你也需要了解常用的网络数据采集手段，以及常用的网络表单安全措施，以提高网站访问的安全性，所谓道高一尺，魔高一丈……一念清净，烈焰成池，一念觉醒，方登彼岸，本书试图成为解决这些问题的一念，让你茅塞顿开，船登彼岸。&lt;/p&gt;
&lt;p&gt;网络数据采集并不是一门语言的独门秘籍，Python、Java、PHP、C#、Go等语言都可以讲出精彩的故事。有人说编程语言就是宗教，不同语言的设计哲学不同，行为方式各异，“非我族类，其心必异”，但本着美好生活、快乐修行的初衷，我们对所有语言都时刻保持敬畏之心，尊重信仰自由，努力做好自己的功课。对爱好Python的人来说，人生苦短，Python当歌！简洁轻松的语法，开箱即用的模块，强大快乐的社区，总可以快速构建出简单高效的解决方案。使用Python的日子总是充满快乐的，本书关于Python网络数据采集的故事也不例外。网络数据采集涉及多个领域，内容包罗万象，因此本书覆盖的主题较多，涉及的知识面相对广阔，书中介绍的Python模块有urllib、BeautifulSoup、lxml、Scrapy、PdfMiner、requests、Selenium、NLTK、Pillow、unittest、PySocks等，还有一些知名网站的API、MySQL数据库、OpenRefine数据分析工具、PhanthomJS无头浏览器以及Tor代理服务器等内容。每行到一处，皆是风景独好，而且作者也为每一个主题提供了深入研究的参考资料。不过，本书关于多进程（multiprocessing）、并发（concurrency）、集群（cluster）等高性能采集主题着墨不多，更加关注性能的读者，可以参考其他关于Python高性能和多核编程的书籍。总之，本书通俗易懂，简单易行，有编程基础的同学都可以阅读。不会Python？抽一节课时间学一下吧。&lt;/p&gt;
&lt;p&gt;网络数据采集也应该有所不为。国内外关于网络数据保护的法律法规都在不断地制定与完善中，本书作者在书中介绍了美国与网络数据采集相关的法律与典型案例，呼吁网络爬虫严格控制网络数据采集的速度，降低被采集网站服务器的负担。恶意消耗别人网站的服务器资源，甚至拖垮别人网站是一件不道德的事情。众所周知，这已经不仅仅是一句“吸烟有害健康”之类的空洞口号，它可能导致更严重的法律后果，且行且珍惜！&lt;/p&gt;
&lt;p&gt;语言是思想的解释器，书籍是语言的载体。本书英文原著是作者用英文解释器为自己思想写的载体，而译本是译者根据英文原著以及与作者的交流，用简体中文解释器为作者思想写的载体。读者拿到的中译本，是作者思想经过两层解释器转换的结果，其目的是希望帮助中文读者消除语言障碍，理解作者的思想，与作者产生共鸣，一起面对作者曾经遇到的问题，共同探索解决问题的方法，从而帮助读者提高解决问题的能力，增强直面bug的信心。bug是产品生命中的挑战，好产品是不断面对bug并战胜bug的结果。译者水平有限，译文bug也在所难免，翻译有不到之处，还请各位读者批评指正！&lt;/p&gt;
&lt;p&gt;最后要感谢图灵公司朱巍老师的大力支持，让译作得以顺利出版。也要感谢神烦小宝的温馨陪伴，每天6点叫我们起床，让业余时间格外宽裕。&lt;/p&gt;
&lt;p&gt;2015年10月&lt;/p&gt;&lt;/div&gt;</description><category>CHS</category><category>Python</category><guid>https://muxuezi.github.io/posts/chs-web-scarping-with-python.html</guid><pubDate>Wed, 08 Jun 2016 11:22:38 GMT</pubDate></item><item><title>Zen of Python</title><link>https://muxuezi.github.io/posts/zen-of-python.html</link><dc:creator>Tao Junjie</dc:creator><description>&lt;div&gt;&lt;h2&gt;Python已经25岁&lt;/h2&gt;
&lt;p&gt;&lt;strong&gt;祝Python生日快乐！&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;img alt="happy25" src="https://muxuezi.github.io/posts/happy25.jpg"&gt;&lt;/p&gt;
&lt;p&gt;1991年2月20日，荷兰人（Dutch）Guido van Rossum发布了Python的0.9.0版，至今25年。Python简洁优雅高效，应用极其广泛，在科学计算、机器学习、系统管理、网络开发等众多领域愈加光彩夺目。译Python设计哲学分享给大家：&lt;/p&gt;
&lt;pre class="code literal-block"&gt;&lt;span&gt;&lt;/span&gt;Python设计哲学，作者Tim Peters（The Zen of Python, by Tim Peters）

美观优于丑陋（Beautiful is better than ugly.）
显明胜过隐晦（Explicit is better than implicit.）
复杂优于混乱（Complex is better than complicated.）
扁平胜过嵌套（Flat is better than nested.）
广泛优于深邃（Sparse is better than dense.）
可读性不可或缺（Readability counts.）
特例不能破坏规则（Special cases aren't special enough to break the rules.）
即使复杂现实会打破纯粹规则（Although practicality beats purity.）
异常不能不辞而别（Errors should never pass silently.）
除非需要它悄然无声（Unless explicitly silenced.）
模棱两可时，不要胡思乱想（In the face of ambiguity, refuse the temptation to guess.）
应该有且仅有一种明确的方式解决问题（There should be one-- and preferably only one-- obvious way to do it.）
虽然那种方式起初并非显而易见，除非你是Guido（Although that way may not be obvious at first unless you're Dutch.）
现在做比不做好（Now is better than never.）
虽然不做比急于求成好（Although never is often better than *right* now.）
如果结果很难解释，一定不靠谱（If the implementation is hard to explain, it's a bad idea.）
如果容易解释，也许行得通（If the implementation is easy to explain, it may be a good idea.）.
命名空间是个非常好的理念——让我们继续努力吧！（Namespaces are one honking great idea -- let's do more of those!）
&lt;/pre&gt;


&lt;blockquote&gt;
&lt;p&gt;原文在&lt;a href="https://www.python.org/"&gt;Python官方网站&lt;/a&gt;打开shell（黄色按钮），命令行里输入import this即可看到。&lt;/p&gt;
&lt;p&gt;Guido大叔今年60岁（1956年1月31日），依然在为Python社区贡献力量，写代码，做演讲，宣传Python新特性，乐此不疲。人生苦短，Python当歌！&lt;/p&gt;
&lt;/blockquote&gt;&lt;/div&gt;</description><category>Python</category><guid>https://muxuezi.github.io/posts/zen-of-python.html</guid><pubDate>Sun, 21 Feb 2016 05:20:52 GMT</pubDate></item><item><title>6.Utilizing Parallel Python</title><link>https://muxuezi.github.io/posts/6utilizing-parallel-python.html</link><dc:creator>Tao Junjie</dc:creator><description>&lt;div tabindex="-1" id="notebook" class="border-box-sizing"&gt;
    &lt;div class="container" id="notebook-container"&gt;

&lt;div class="cell border-box-sizing text_cell rendered"&gt;
&lt;div class="prompt input_prompt"&gt;
&lt;/div&gt;
&lt;div class="inner_cell"&gt;
&lt;div class="text_cell_render border-box-sizing rendered_html"&gt;
&lt;h2 id="用Parallel-Python模块"&gt;用Parallel Python模块&lt;a class="anchor-link" href="https://muxuezi.github.io/posts/6utilizing-parallel-python.html#%E7%94%A8Parallel-Python%E6%A8%A1%E5%9D%97"&gt;¶&lt;/a&gt;&lt;/h2&gt;&lt;p&gt;上一章我们用&lt;code&gt;multiprocessing&lt;/code&gt;和&lt;code&gt;ProcessPoolExecutor&lt;/code&gt;模块演示了两个例子。这一章我们将介绍命名队列（named pipe）的用法，以及如何用&lt;strong&gt; Parallel Python (PP)&lt;/strong&gt;模块的进程解决问题。&lt;/p&gt;
&lt;p&gt;本章内容包括以下主题：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;理解进程间通信概念&lt;/li&gt;
&lt;li&gt;介绍PP模块&lt;/li&gt;
&lt;li&gt;用PP在SMP架上计算Fibonacci数列&lt;/li&gt;
&lt;li&gt;用PP实现并行网络爬虫&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;a href="https://muxuezi.github.io/posts/6utilizing-parallel-python.html"&gt;Read more…&lt;/a&gt; (3 min remaining to read)&lt;/p&gt;&lt;/div&gt;&lt;/div&gt;&lt;/div&gt;&lt;/div&gt;&lt;/div&gt;</description><category>Parallel Programming with Python</category><category>Python</category><guid>https://muxuezi.github.io/posts/6utilizing-parallel-python.html</guid><pubDate>Sat, 03 Oct 2015 04:44:35 GMT</pubDate></item><item><title>5.Using Multiprocessing and ProcessPoolExecutor</title><link>https://muxuezi.github.io/posts/5using-multiprocessing-and-processpoolexecutor.html</link><dc:creator>Tao Junjie</dc:creator><description>&lt;div tabindex="-1" id="notebook" class="border-box-sizing"&gt;
    &lt;div class="container" id="notebook-container"&gt;

&lt;div class="cell border-box-sizing text_cell rendered"&gt;
&lt;div class="prompt input_prompt"&gt;
&lt;/div&gt;
&lt;div class="inner_cell"&gt;
&lt;div class="text_cell_render border-box-sizing rendered_html"&gt;
&lt;h2 id="用multiprocessing和ProcessPoolExecutor模块"&gt;用&lt;code&gt;multiprocessing&lt;/code&gt;和&lt;code&gt;ProcessPoolExecutor&lt;/code&gt;模块&lt;a class="anchor-link" href="https://muxuezi.github.io/posts/5using-multiprocessing-and-processpoolexecutor.html#%E7%94%A8multiprocessing%E5%92%8CProcessPoolExecutor%E6%A8%A1%E5%9D%97"&gt;¶&lt;/a&gt;&lt;/h2&gt;&lt;p&gt;上一章我们用&lt;code&gt;threading&lt;/code&gt;模块演示了两个例子。这一章我们将介绍&lt;code&gt;multiprocessing&lt;/code&gt;的用法，实现与&lt;code&gt;threading&lt;/code&gt;类似的接口。但是，我们将用进程范式。&lt;/p&gt;
&lt;p&gt;本章内容包括以下主题：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;理解进程的概念&lt;/li&gt;
&lt;li&gt;理解多进程通信&lt;/li&gt;
&lt;li&gt;用&lt;code&gt;multiprocessing&lt;/code&gt;实现多请求的Fibonacci数列&lt;/li&gt;
&lt;li&gt;用&lt;code&gt;ProcessPoolExecutor&lt;/code&gt;实现并行网络爬虫&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;a href="https://muxuezi.github.io/posts/5using-multiprocessing-and-processpoolexecutor.html"&gt;Read more…&lt;/a&gt; (2 min remaining to read)&lt;/p&gt;&lt;/div&gt;&lt;/div&gt;&lt;/div&gt;&lt;/div&gt;&lt;/div&gt;</description><category>Parallel Programming with Python</category><category>Python</category><guid>https://muxuezi.github.io/posts/5using-multiprocessing-and-processpoolexecutor.html</guid><pubDate>Tue, 29 Sep 2015 12:53:28 GMT</pubDate></item><item><title>4.Using the threading and concurrent.futures Modules</title><link>https://muxuezi.github.io/posts/4using-the-threading-and-concurrentfutures-modules.html</link><dc:creator>Tao Junjie</dc:creator><description>&lt;div tabindex="-1" id="notebook" class="border-box-sizing"&gt;
    &lt;div class="container" id="notebook-container"&gt;

&lt;div class="cell border-box-sizing text_cell rendered"&gt;
&lt;div class="prompt input_prompt"&gt;
&lt;/div&gt;
&lt;div class="inner_cell"&gt;
&lt;div class="text_cell_render border-box-sizing rendered_html"&gt;
&lt;h2 id="4.用threading和concurrent.futures模块"&gt;4.用&lt;code&gt;threading&lt;/code&gt;和&lt;code&gt;concurrent.futures&lt;/code&gt;模块&lt;a class="anchor-link" href="https://muxuezi.github.io/posts/4using-the-threading-and-concurrentfutures-modules.html#4.%E7%94%A8threading%E5%92%8Cconcurrent.futures%E6%A8%A1%E5%9D%97"&gt;¶&lt;/a&gt;&lt;/h2&gt;&lt;p&gt;在上一章，我们总结了并行思想可以解决的一些问题。这一章，我们将用Python的&lt;code&gt;threading&lt;/code&gt;模块实现每个问题的解决方案。&lt;/p&gt;
&lt;p&gt;本章内容包括以下主题：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;线程的定义&lt;/li&gt;
&lt;li&gt;&lt;code&gt;threading&lt;/code&gt;和&lt;code&gt;_thread&lt;/code&gt;的选择&lt;/li&gt;
&lt;li&gt;用&lt;code&gt;threading&lt;/code&gt;实现多请求的Fibonacci数列&lt;/li&gt;
&lt;li&gt;用&lt;code&gt;concurrent.futures&lt;/code&gt;模块实现网络爬虫&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;a href="https://muxuezi.github.io/posts/4using-the-threading-and-concurrentfutures-modules.html"&gt;Read more…&lt;/a&gt; (2 min remaining to read)&lt;/p&gt;&lt;/div&gt;&lt;/div&gt;&lt;/div&gt;&lt;/div&gt;&lt;/div&gt;</description><category>Parallel Programming with Python</category><category>Python</category><guid>https://muxuezi.github.io/posts/4using-the-threading-and-concurrentfutures-modules.html</guid><pubDate>Mon, 28 Sep 2015 12:42:03 GMT</pubDate></item><item><title>2-working-with-linear-models</title><link>https://muxuezi.github.io/posts/2-working-with-linear-models.html</link><dc:creator>Tao Junjie</dc:creator><description>&lt;div tabindex="-1" id="notebook" class="border-box-sizing"&gt;
    &lt;div class="container" id="notebook-container"&gt;

&lt;div class="cell border-box-sizing text_cell rendered"&gt;
&lt;div class="prompt input_prompt"&gt;
&lt;/div&gt;
&lt;div class="inner_cell"&gt;
&lt;div class="text_cell_render border-box-sizing rendered_html"&gt;
&lt;h2 id="处理线性模型"&gt;处理线性模型&lt;a class="anchor-link" href="https://muxuezi.github.io/posts/2-working-with-linear-models.html#%E5%A4%84%E7%90%86%E7%BA%BF%E6%80%A7%E6%A8%A1%E5%9E%8B"&gt;¶&lt;/a&gt;&lt;/h2&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div class="cell border-box-sizing text_cell rendered"&gt;
&lt;div class="prompt input_prompt"&gt;
&lt;/div&gt;
&lt;div class="inner_cell"&gt;
&lt;div class="text_cell_render border-box-sizing rendered_html"&gt;
&lt;p&gt;本章包括以下主题：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;&lt;a href="https://muxuezi.github.io/posts/fitting-a-line-through-data.html"&gt;线性回归模型&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="https://muxuezi.github.io/posts/evaluating-the-linear-regression-model.html"&gt;评估线性回归模型&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="https://muxuezi.github.io/posts/using-ridge-regression-to-overcome-linear-regression-shortfalls.html"&gt;用岭回归弥补线性回归的不足&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="https://muxuezi.github.io/posts/optimizing-the-ridge-regression-parameter.html"&gt;优化岭回归参数&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="https://muxuezi.github.io/posts/using-sparsity-to-regularize-models.html"&gt;LASSO正则化&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="https://muxuezi.github.io/posts/taking-a-more-fundamental-approach-to-regularization-with-lars.html"&gt;LARS正则化&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="https://muxuezi.github.io/posts/using-linear-methods-for-classification-logistic-regression.html"&gt;用线性方法处理分类问题——逻辑回归&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="https://muxuezi.github.io/posts/directly-applying-bayesian-ridge-regression.html"&gt;贝叶斯岭回归&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="https://muxuezi.github.io/posts/using-boosting-to-learn-from-errors.html"&gt;用梯度提升回归从误差中学习&lt;/a&gt;&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;&lt;a href="https://muxuezi.github.io/posts/2-working-with-linear-models.html"&gt;Read more…&lt;/a&gt; (1 min remaining to read)&lt;/p&gt;&lt;/div&gt;&lt;/div&gt;&lt;/div&gt;&lt;/div&gt;&lt;/div&gt;</description><category>CHS</category><category>ipython</category><category>Machine Learning</category><category>Python</category><category>scikit-learn cookbook</category><guid>https://muxuezi.github.io/posts/2-working-with-linear-models.html</guid><pubDate>Tue, 18 Aug 2015 05:07:14 GMT</pubDate></item><item><title>directly-applying-bayesian-ridge-regression</title><link>https://muxuezi.github.io/posts/directly-applying-bayesian-ridge-regression.html</link><dc:creator>Tao Junjie</dc:creator><description>&lt;div tabindex="-1" id="notebook" class="border-box-sizing"&gt;
    &lt;div class="container" id="notebook-container"&gt;

&lt;div class="cell border-box-sizing text_cell rendered"&gt;
&lt;div class="prompt input_prompt"&gt;
&lt;/div&gt;
&lt;div class="inner_cell"&gt;
&lt;div class="text_cell_render border-box-sizing rendered_html"&gt;
&lt;h2 id="贝叶斯岭回归"&gt;贝叶斯岭回归&lt;a class="anchor-link" href="https://muxuezi.github.io/posts/directly-applying-bayesian-ridge-regression.html#%E8%B4%9D%E5%8F%B6%E6%96%AF%E5%B2%AD%E5%9B%9E%E5%BD%92"&gt;¶&lt;/a&gt;&lt;/h2&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div class="cell border-box-sizing text_cell rendered"&gt;
&lt;div class="prompt input_prompt"&gt;
&lt;/div&gt;
&lt;div class="inner_cell"&gt;
&lt;div class="text_cell_render border-box-sizing rendered_html"&gt;
&lt;p&gt;在&lt;em&gt;用岭回归弥补线性回归的不足&lt;/em&gt;主题中，我们介绍了岭回归优化的限制条件。我们还介绍了相关系数的先验概率分布的贝叶斯解释，将很大程度地影响着先验概率分布，先验概率分布通常均值是0。&lt;/p&gt;
&lt;p&gt;因此，现在我们就来演示如何scikit-learn来应用这种解释。&lt;/p&gt;
&lt;p&gt;&lt;a href="https://muxuezi.github.io/posts/directly-applying-bayesian-ridge-regression.html"&gt;Read more…&lt;/a&gt; (1 min remaining to read)&lt;/p&gt;&lt;/div&gt;&lt;/div&gt;&lt;/div&gt;&lt;/div&gt;&lt;/div&gt;</description><category>CHS</category><category>ipython</category><category>Machine Learning</category><category>Python</category><category>scikit-learn cookbook</category><guid>https://muxuezi.github.io/posts/directly-applying-bayesian-ridge-regression.html</guid><pubDate>Tue, 18 Aug 2015 04:57:47 GMT</pubDate></item><item><title>evaluating-the-linear-regression-model</title><link>https://muxuezi.github.io/posts/evaluating-the-linear-regression-model.html</link><dc:creator>Tao Junjie</dc:creator><description>&lt;div tabindex="-1" id="notebook" class="border-box-sizing"&gt;
    &lt;div class="container" id="notebook-container"&gt;

&lt;div class="cell border-box-sizing text_cell rendered"&gt;
&lt;div class="prompt input_prompt"&gt;
&lt;/div&gt;
&lt;div class="inner_cell"&gt;
&lt;div class="text_cell_render border-box-sizing rendered_html"&gt;
&lt;h2 id="评估线性回归模型"&gt;评估线性回归模型&lt;a class="anchor-link" href="https://muxuezi.github.io/posts/evaluating-the-linear-regression-model.html#%E8%AF%84%E4%BC%B0%E7%BA%BF%E6%80%A7%E5%9B%9E%E5%BD%92%E6%A8%A1%E5%9E%8B"&gt;¶&lt;/a&gt;&lt;/h2&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div class="cell border-box-sizing text_cell rendered"&gt;
&lt;div class="prompt input_prompt"&gt;
&lt;/div&gt;
&lt;div class="inner_cell"&gt;
&lt;div class="text_cell_render border-box-sizing rendered_html"&gt;
&lt;p&gt;在这个主题中，我们将介绍回归模型拟合数据的效果。上一个主题我们拟合了数据，但是并没太关注拟合的效果。每当拟合工作做完之后，我们应该问的第一个问题就是“拟合的效果如何？”本主题将回答这个问题。&lt;/p&gt;
&lt;p&gt;&lt;a href="https://muxuezi.github.io/posts/evaluating-the-linear-regression-model.html"&gt;Read more…&lt;/a&gt; (2 min remaining to read)&lt;/p&gt;&lt;/div&gt;&lt;/div&gt;&lt;/div&gt;&lt;/div&gt;&lt;/div&gt;</description><category>CHS</category><category>ipython</category><category>Machine Learning</category><category>Python</category><category>scikit-learn cookbook</category><guid>https://muxuezi.github.io/posts/evaluating-the-linear-regression-model.html</guid><pubDate>Tue, 18 Aug 2015 04:57:47 GMT</pubDate></item><item><title>fitting-a-line-through-data</title><link>https://muxuezi.github.io/posts/fitting-a-line-through-data.html</link><dc:creator>Tao Junjie</dc:creator><description>&lt;div tabindex="-1" id="notebook" class="border-box-sizing"&gt;
    &lt;div class="container" id="notebook-container"&gt;

&lt;div class="cell border-box-sizing text_cell rendered"&gt;
&lt;div class="prompt input_prompt"&gt;
&lt;/div&gt;
&lt;div class="inner_cell"&gt;
&lt;div class="text_cell_render border-box-sizing rendered_html"&gt;
&lt;h2 id="线性回归模型"&gt;线性回归模型&lt;a class="anchor-link" href="https://muxuezi.github.io/posts/fitting-a-line-through-data.html#%E7%BA%BF%E6%80%A7%E5%9B%9E%E5%BD%92%E6%A8%A1%E5%9E%8B"&gt;¶&lt;/a&gt;&lt;/h2&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div class="cell border-box-sizing text_cell rendered"&gt;
&lt;div class="prompt input_prompt"&gt;
&lt;/div&gt;
&lt;div class="inner_cell"&gt;
&lt;div class="text_cell_render border-box-sizing rendered_html"&gt;
&lt;p&gt;现在，我们来做一些建模！我们从最简单的线性回归（Linear regression）开始。线性回归是最早的也是最基本的模型——把数据拟合成一条直线。&lt;/p&gt;
&lt;p&gt;&lt;a href="https://muxuezi.github.io/posts/fitting-a-line-through-data.html"&gt;Read more…&lt;/a&gt; (1 min remaining to read)&lt;/p&gt;&lt;/div&gt;&lt;/div&gt;&lt;/div&gt;&lt;/div&gt;&lt;/div&gt;</description><category>CHS</category><category>ipython</category><category>Machine Learning</category><category>Python</category><category>scikit-learn cookbook</category><guid>https://muxuezi.github.io/posts/fitting-a-line-through-data.html</guid><pubDate>Tue, 18 Aug 2015 04:57:47 GMT</pubDate></item></channel></rss>